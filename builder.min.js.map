{"version":3,"file":"builder.min.js","sources":["../src/state.ts","../src/data.ts","../src/draw.ts","../src/main.ts"],"sourcesContent":["// src/state.ts\n\ninterface State {\n  scale: number;\n  offset: { x: number; y: number };\n  isSelecting: boolean;\n  selectionStart: { x: number; y: number };\n  selectionEnd: { x: number; y: number };\n  isJoining: boolean;\n  joinStart: { x: number; y: number };\n  joinEnd: { x: number; y: number };\n  joinStartId: number | null;\n  joinEndId: number | null;\n}\n\nexport const state: State = {\n  scale: 1,\n  offset: { x: 0, y: 0 },\n  // Selecting\n  isSelecting: false,\n  selectionStart: { x: 0, y: 0 },\n  selectionEnd: { x: 0, y: 0 },\n  // Joining\n  isJoining: false,\n  joinStart: { x: 0, y: 0 },\n  joinEnd: { x: 0, y: 0 },\n  joinStartId: null,\n  joinEndId: null,\n};\n\nexport function setScale(newScale: number) {\n  state.scale = newScale;\n}\n\nexport function setOffset(newOffset: { x: number; y: number }) {\n  state.offset = newOffset;\n}\n\nexport function setIsSelecting(newIsSelecting: boolean) {\n  state.isSelecting = newIsSelecting;\n}\n\nexport function setSelectionStart(newSelectionStart: { x: number; y: number }) {\n  state.selectionStart = newSelectionStart;\n}\n\nexport function setSelectionEnd(newSelectionEnd: { x: number; y: number }) {\n  state.selectionEnd = newSelectionEnd;\n}\n\nexport function setIsJoining(newIsJoining: boolean) {\n  state.isJoining = newIsJoining;\n}\n\nexport function setJoinStart(newJoinStart: { x: number; y: number }) {\n  state.joinStart = newJoinStart;\n}\n\nexport function setJoinEnd(newJoinEnd: { x: number; y: number }) {\n  state.joinEnd = newJoinEnd;\n}\n\nexport function setJoinStartId(newJoinStartId: number | null) {\n  state.joinStartId = newJoinStartId;\n}\n\nexport function setJoinEndId(newJoinEndId: number | null) {\n  state.joinEndId = newJoinEndId;\n}\n","// src/data.ts\nimport { Data } from './types';\n\n// Initial data state\nexport let data: Data = {\n  nodes: [\n    {\n      id: 1,\n      position: { x: 100, y: 100 },\n      size: { width: 80, height: 40 },\n      selected: false,\n      type: 'input',\n      name: 'Input',\n      outputPins: [{ id: 85, value: 2, type: 'number' }],\n    },\n    {\n      id: 2,\n      position: { x: 200, y: 200 },\n      size: { width: 80, height: 40 },\n      selected: false,\n      type: 'input',\n      name: 'Input',\n      outputPins: [{ id: 86, value: 10, type: 'number' }],\n    },\n    {\n      id: 3,\n      position: { x: 300, y: 300 },\n      size: { width: 80, height: 40 },\n      selected: false,\n      type: 'function',\n      name: 'Multiply',\n      functionId: 'sd78f979f8ds',\n      inputPins: [\n        { id: 87, type: 'number' },\n        { id: 88, type: 'number' },\n      ],\n      outputPins: [\n        { id: 89, value: 10, type: 'number' },\n        { id: 810, value: 10, type: 'error' },\n      ],\n      solved: true,\n    },\n    {\n      id: 5,\n      position: { x: 400, y: 400 },\n      size: { width: 80, height: 40 },\n      selected: false,\n      type: 'output',\n      name: 'Output',\n      inputPins: [{ id: 811, type: 'error' }],\n    },\n    {\n      id: 4,\n      position: { x: 400, y: 400 },\n      size: { width: 80, height: 40 },\n      selected: false,\n      type: 'error',\n      name: 'Error',\n      inputPins: [{ id: 812, type: 'number' }],\n    },\n  ],\n  edges: [\n    { start: 85, end: 87, selected: true },\n    { start: 86, end: 88, selected: false },\n    { start: 89, end: 811, selected: false },\n    { start: 810, end: 812, selected: false },\n  ],\n  solved: true,\n};\n\n// History management\nlet history = [JSON.stringify(data)]; // Initial state in history\nlet currentIndex = 0; // Current state index in history\n\n// Function to capture the current state into history with size limit\nexport function captureState() {\n  const currentState = JSON.stringify(data);\n  if (history[currentIndex] !== currentState) {\n    if (currentIndex < history.length - 1) {\n      history = history.slice(0, currentIndex + 1);\n    }\n    history.push(currentState);\n\n    if (history.length > 50) {\n      history.shift(); // Remove the oldest state\n    } else {\n      currentIndex++; // Advance the current index to the new state\n    }\n\n    console.log(\n      'captureState: New state captured, currentIndex:',\n      currentIndex\n    );\n  }\n}\n\n// Function to emit an event indicating data has changed\nfunction emitDataChanged() {\n  document.dispatchEvent(new CustomEvent('dataChanged'));\n}\n\n// Function to undo the last action\nexport function undo() {\n  if (currentIndex > 0) {\n    currentIndex--;\n    data = JSON.parse(history[currentIndex]);\n    console.log(\n      'undo: State reverted to currentIndex:',\n      currentIndex,\n      'data:',\n      data\n    );\n  } else {\n    console.log('undo: No more states to revert to');\n  }\n}\n\n// Function to redo the previously undone action\nexport function redo() {\n  if (currentIndex < history.length - 1) {\n    currentIndex++;\n    data = JSON.parse(history[currentIndex]);\n    console.log(\n      'redo: State advanced to currentIndex:',\n      currentIndex,\n      'data:',\n      data\n    );\n  } else {\n    console.log('redo: No more states to advance to');\n  }\n}\n","// src/draw.ts\nimport { state } from './state';\nimport { data } from './data';\nimport { Node, Position } from './types';\n\n// Pins\nexport const baseCircleDiameter = 10;\nconst baseSpaceBetweenCircles = 5;\n\nexport function getPinPositions(\n  node: Node,\n  scale: number,\n  offset: Position\n): Array<{ id: number; type: 'input' | 'output'; position: Position }> {\n  const positions: Array<{\n    id: number;\n    type: 'input' | 'output';\n    position: Position;\n  }> = [];\n\n  const circleDiameter = baseCircleDiameter * scale;\n  const circleRadius = circleDiameter / 2;\n  const spaceBetweenCircles = baseSpaceBetweenCircles * scale;\n\n  const outputPins = node.outputPins ?? [];\n  let currentXOutput =\n    node.position.x * scale +\n    offset.x +\n    (node.size.width * scale -\n      (outputPins.length * circleDiameter +\n        (outputPins.length - 1) * spaceBetweenCircles)) /\n      2 +\n    circleRadius;\n  outputPins.forEach(pin => {\n    positions.push({\n      id: pin.id,\n      type: 'output',\n      position: {\n        x: currentXOutput,\n        y:\n          node.position.y * scale +\n          offset.y +\n          node.size.height * scale +\n          circleRadius +\n          5 * scale,\n      },\n    });\n    currentXOutput += circleDiameter + spaceBetweenCircles;\n  });\n\n  const inputPins = node.inputPins ?? [];\n  let currentXInput =\n    node.position.x * scale +\n    offset.x +\n    (node.size.width * scale -\n      (inputPins.length * circleDiameter +\n        (inputPins.length - 1) * spaceBetweenCircles)) /\n      2 +\n    circleRadius;\n  inputPins.forEach((pin, index) => {\n    positions.push({\n      id: pin.id,\n      type: 'input',\n      position: {\n        x: currentXInput,\n        y: node.position.y * scale + offset.y - circleRadius - 5 * scale,\n      },\n    });\n    currentXInput += circleDiameter + spaceBetweenCircles;\n  });\n\n  return positions;\n}\n\nexport function drawNodes(mainCtx: CanvasRenderingContext2D): void {\n  const { scale, offset } = state;\n  data.nodes.forEach(node => {\n    const borderRadius = 4 * scale;\n    const { x, y, width, height } = {\n      x: node.position.x * scale + offset.x,\n      y: node.position.y * scale + offset.y,\n      width: node.size.width * scale,\n      height: node.size.height * scale,\n    };\n\n    // Set up drop shadow\n    mainCtx.shadowColor = 'rgba(0, 0, 0, 0.3)'; // Shadow color with some transparency\n    mainCtx.shadowBlur = 8; // How much the shadow will be blurred\n    mainCtx.shadowOffsetX = 4; // Horizontal shadow offset\n    mainCtx.shadowOffsetY = 4; // Vertical shadow offset\n\n    mainCtx.beginPath();\n    mainCtx.moveTo(x + borderRadius, y);\n    mainCtx.lineTo(x + width - borderRadius, y);\n    mainCtx.quadraticCurveTo(x + width, y, x + width, y + borderRadius);\n    mainCtx.lineTo(x + width, y + height - borderRadius);\n    mainCtx.quadraticCurveTo(\n      x + width,\n      y + height,\n      x + width - borderRadius,\n      y + height\n    );\n    mainCtx.lineTo(x + borderRadius, y + height);\n    mainCtx.quadraticCurveTo(x, y + height, x, y + height - borderRadius);\n    mainCtx.lineTo(x, y + borderRadius);\n    mainCtx.quadraticCurveTo(x, y, x + borderRadius, y);\n    mainCtx.closePath();\n\n    mainCtx.fillStyle = 'rgba(133, 133, 133, 0.7)';\n    mainCtx.fill();\n\n    // Draw name text with 0.5 transparency next to the node\n    mainCtx.fillStyle = 'rgba(255, 255, 255, 0.5)'; // Set the text color with transparency\n    mainCtx.font = `${14 * scale}px Arial`; // Set the font size and family. Adjust as needed.\n    const textMargin = 10; // Adjust the margin from the node to the text as needed\n    const textX = x + width + textMargin; // Position the text to the right of the node\n    const textY = y + height / 2 + 5; // Center text vertically relative to the node. Adjust as needed.\n    mainCtx.fillText(node.name, textX, textY);\n\n    // Only apply gold border if node is selected\n    if (node.selected) {\n      mainCtx.strokeStyle = 'gold';\n      mainCtx.lineWidth = 2.5 * scale;\n      mainCtx.stroke();\n    }\n\n    const pinPositions = getPinPositions(node, scale, offset);\n    pinPositions.forEach(({ id, type, position }) => {\n      const pinRadius = (baseCircleDiameter / 2) * scale;\n      mainCtx.beginPath();\n      mainCtx.arc(position.x, position.y, pinRadius, 0, 2 * Math.PI);\n      mainCtx.fillStyle = 'grey'; // Grey color for the main pin\n\n      // Add subtle drop shadow to pins\n      mainCtx.shadowColor = 'rgba(0, 0, 0, 0.5)';\n      mainCtx.shadowBlur = 5;\n      mainCtx.shadowOffsetX = 2;\n      mainCtx.shadowOffsetY = 2;\n\n      mainCtx.fill();\n\n      // Reset shadow properties to avoid shadow on the small circle\n      mainCtx.shadowColor = 'transparent';\n      mainCtx.shadowBlur = 0;\n      mainCtx.shadowOffsetX = 0;\n      mainCtx.shadowOffsetY = 0;\n\n      // Drawing a small dark grey circle in the middle of the pin\n      mainCtx.beginPath();\n      const smallCircleRadius = pinRadius * 0.4; // Adjust the size of the small circle as needed\n      mainCtx.arc(position.x, position.y, smallCircleRadius, 0, 2 * Math.PI);\n      mainCtx.fillStyle = 'rgba(0, 0, 0, 0.7)'; // Dark grey color for the small circle\n      mainCtx.fill();\n    });\n\n    // Reset shadow properties after drawing to avoid affecting other canvas elements\n    mainCtx.shadowColor = 'transparent';\n    mainCtx.shadowBlur = 0;\n    mainCtx.shadowOffsetX = 0;\n    mainCtx.shadowOffsetY = 0;\n  });\n}\n\nexport function drawEdges(mainCtx: CanvasRenderingContext2D): void {\n  const { scale, offset } = state;\n  mainCtx.lineWidth = 2.5 * scale;\n\n  // Configure drop shadow properties\n  mainCtx.shadowColor = 'rgba(0, 0, 0, 0.5)'; // Semi-transparent black\n  mainCtx.shadowBlur = 10 * scale; // Adjust the blur radius based on your scale\n  mainCtx.shadowOffsetX = 5 * scale; // Horizontal shadow offset\n  mainCtx.shadowOffsetY = 5 * scale; // Vertical shadow offset\n\n  // Set lineCap to 'round' for rounded ends\n  mainCtx.lineCap = 'round';\n\n  data.edges.forEach(edge => {\n    const startNode = data.nodes.find(node =>\n      node.outputPins?.some(pin => pin.id === edge.start)\n    );\n    const endNode = data.nodes.find(node =>\n      node.inputPins?.some(pin => pin.id === edge.end)\n    );\n\n    if (!startNode || !endNode || !startNode.outputPins || !endNode.inputPins) {\n      return;\n    }\n\n    const startPin = startNode.outputPins.find(pin => pin.id === edge.start);\n    const endPin = endNode.inputPins.find(pin => pin.id === edge.end);\n    if (!startPin || !endPin) {\n      return;\n    }\n\n    if (startPin.type === 'error') {\n      mainCtx.strokeStyle = edge.selected ? 'gold' : '#D04545';\n    } else {\n      mainCtx.strokeStyle = edge.selected ? 'gold' : '#4181DC'; // Existing logic for other edges\n    }\n\n    const circleDiameter = baseCircleDiameter * scale;\n    const circleRadius = circleDiameter / 2;\n    const spaceBetweenCircles = baseSpaceBetweenCircles * scale;\n    const startPinIndex = startNode.outputPins.indexOf(startPin);\n    const endPinIndex = endNode.inputPins.indexOf(endPin);\n\n    const startX =\n      startNode.position.x * scale +\n      offset.x +\n      (startNode.size.width * scale -\n        (startNode.outputPins.length * circleDiameter +\n          (startNode.outputPins.length - 1) * spaceBetweenCircles)) /\n        2 +\n      startPinIndex * (circleDiameter + spaceBetweenCircles) +\n      circleRadius;\n    const startY =\n      startNode.position.y * scale +\n      offset.y +\n      startNode.size.height * scale +\n      circleRadius +\n      5 * scale;\n\n    const endX =\n      endNode.position.x * scale +\n      offset.x +\n      (endNode.size.width * scale -\n        (endNode.inputPins.length * circleDiameter +\n          (endNode.inputPins.length - 1) * spaceBetweenCircles)) /\n        2 +\n      endPinIndex * (circleDiameter + spaceBetweenCircles) +\n      circleRadius;\n    const endY =\n      endNode.position.y * scale + offset.y - circleRadius - 5 * scale;\n\n    const dx = endX - startX;\n    const dy = endY - startY;\n\n    const offsetMagnitude = Math.sqrt(dx * dx + dy * dy) / 3;\n    const cp1X = startX + dx / 3;\n    const cp1Y = startY + (dy < 0 ? -1 : 1) * offsetMagnitude;\n    const cp2X = endX - dx / 3;\n    const cp2Y = endY - (dy < 0 ? -1 : 1) * offsetMagnitude;\n\n    mainCtx.beginPath();\n    mainCtx.moveTo(startX, startY);\n    mainCtx.bezierCurveTo(cp1X, cp1Y, cp2X, cp2Y, endX, endY);\n    mainCtx.stroke();\n  });\n\n  // Reset drop shadow properties to avoid affecting other drawings\n  mainCtx.shadowColor = 'transparent';\n  mainCtx.shadowBlur = 0;\n  mainCtx.shadowOffsetX = 0;\n  mainCtx.shadowOffsetY = 0;\n\n  // Reset lineCap to default ('butt') to not affect subsequent drawings\n  mainCtx.lineCap = 'butt';\n}\n\nexport function drawJoiningEdge(\n  ctx: CanvasRenderingContext2D,\n  joinStart: Position,\n  joinEnd: Position,\n  scale: number,\n  offset: Position\n): void {\n  const circleDiameter = baseCircleDiameter * scale;\n  const circleRadius = circleDiameter / 2;\n\n  // Assume joinStart and joinEnd are in canvas space and need to be scaled and offset\n  const startX = joinStart.x * scale + offset.x;\n  const startY = joinStart.y * scale + offset.y; // Adjust as per your pin position logic\n  const endX = joinEnd.x * scale + offset.x;\n  const endY = joinEnd.y * scale + offset.y; // Adjust as per your pin position logic\n\n  const dx = endX - startX;\n  const dy = endY - startY;\n  const offsetMagnitude = Math.sqrt(dx * dx + dy * dy) / 3;\n  const cp1X = startX + dx / 3;\n  const cp1Y = startY + (dy < 0 ? -1 : 1) * offsetMagnitude;\n  const cp2X = endX - dx / 3;\n  const cp2Y = endY - (dy < 0 ? -1 : 1) * offsetMagnitude;\n\n  ctx.beginPath();\n  ctx.moveTo(startX, startY);\n  ctx.bezierCurveTo(cp1X, cp1Y, cp2X, cp2Y, endX, endY);\n  ctx.strokeStyle = 'gold';\n  ctx.stroke();\n}\n\nexport function drawSelection(topCtx: CanvasRenderingContext2D): void {\n  const { scale, offset, selectionEnd, selectionStart } = state;\n  const x = Math.min(selectionStart.x, selectionEnd.x) * scale + offset.x;\n  const y = Math.min(selectionStart.y, selectionEnd.y) * scale + offset.y;\n  const width = Math.abs(selectionEnd.x - selectionStart.x) * scale;\n  const height = Math.abs(selectionEnd.y - selectionStart.y) * scale;\n\n  topCtx.save();\n  topCtx.setLineDash([5, 3]);\n  topCtx.strokeStyle = 'white';\n  topCtx.lineWidth = 1;\n  topCtx.beginPath();\n  topCtx.rect(x, y, width, height);\n  topCtx.stroke();\n  topCtx.restore();\n}\n\nexport function drawBackground(\n  backgroundCtx: CanvasRenderingContext2D,\n  backgroundCanvas: HTMLCanvasElement\n): void {\n  backgroundCtx.fillStyle = '#262626';\n  backgroundCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);\n  drawGrid(backgroundCtx, backgroundCanvas, 20, '#353535', 1);\n  drawGrid(backgroundCtx, backgroundCanvas, 200, '#161616', 2);\n}\n\nexport function drawGrid(\n  backgroundCtx: CanvasRenderingContext2D,\n  backgroundCanvas: HTMLCanvasElement,\n  spacing: number,\n  color: string,\n  lineWidth: number\n): void {\n  const { scale, offset } = state;\n  backgroundCtx.strokeStyle = color;\n  backgroundCtx.lineWidth = lineWidth;\n  const gridSpacing = spacing * scale;\n  const startX = (offset.x % gridSpacing) - gridSpacing;\n  const startY = (offset.y % gridSpacing) - gridSpacing;\n  const endX = backgroundCanvas.width;\n  const endY = backgroundCanvas.height;\n\n  // Draw vertical grid lines\n  for (let x = startX; x < endX; x += gridSpacing) {\n    backgroundCtx.beginPath();\n    backgroundCtx.moveTo(x, 0);\n    backgroundCtx.lineTo(x, endY);\n    backgroundCtx.stroke();\n  }\n\n  // Draw horizontal grid lines\n  for (let y = startY; y < endY; y += gridSpacing) {\n    backgroundCtx.beginPath();\n    backgroundCtx.moveTo(0, y);\n    backgroundCtx.lineTo(endX, y);\n    backgroundCtx.stroke();\n  }\n}\n\nexport function draw(\n  topCanvas: HTMLCanvasElement,\n  mainCanvas: HTMLCanvasElement,\n  backgroundCanvas: HTMLCanvasElement\n): void {\n  const { isSelecting, isJoining, joinStart, joinEnd } = state;\n  const topCtx = topCanvas.getContext('2d');\n  const mainCtx = mainCanvas.getContext('2d');\n  const backgroundCtx = backgroundCanvas.getContext('2d');\n\n  if (!topCtx || !mainCtx || !backgroundCtx) {\n    throw new Error('Canvas not supported');\n  }\n\n  topCtx.clearRect(0, 0, topCanvas.width, topCanvas.height);\n  mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);\n  drawBackground(backgroundCtx, backgroundCanvas);\n\n  drawNodes(mainCtx);\n  drawEdges(mainCtx);\n  if (isSelecting) drawSelection(topCtx);\n\n  if (isJoining && joinStart && joinEnd) {\n    drawJoiningEdge(mainCtx, joinStart, joinEnd, state.scale, state.offset);\n  }\n}\n","// src/main.ts\nimport './styles.scss';\nimport {\n  state,\n  setScale,\n  setOffset,\n  setIsSelecting,\n  setSelectionStart,\n  setSelectionEnd,\n  setIsJoining,\n  setJoinStart,\n  setJoinEnd,\n  setJoinStartId,\n  setJoinEndId,\n} from './state';\n\nimport { draw, getPinPositions, baseCircleDiameter } from './draw';\nimport { data, captureState, redo, undo } from './data';\nimport { Node, Position } from './types';\n\nconst topCanvas = document.getElementById('topCanvas') as HTMLCanvasElement;\nconst mainCanvas = document.getElementById('mainCanvas') as HTMLCanvasElement;\nconst backgroundCanvas = document.getElementById(\n  'backgroundCanvas'\n) as HTMLCanvasElement;\n\nexport function drawNow(): void {\n  draw(topCanvas, mainCanvas, backgroundCanvas);\n}\n\nlet panStartPos = { x: 0, y: 0 };\nlet isPanning = false;\nlet isDragging = false;\nlet actionStartPos = { x: 0, y: 0 };\n\nfunction pointToLineDistance(\n  point: Position,\n  lineStart: Position,\n  lineEnd: Position\n): number {\n  const l2 =\n    Math.pow(lineEnd.x - lineStart.x, 2) + Math.pow(lineEnd.y - lineStart.y, 2);\n  if (l2 === 0)\n    return Math.sqrt(\n      Math.pow(point.x - lineStart.x, 2) + Math.pow(point.y - lineStart.y, 2)\n    );\n  let t =\n    ((point.x - lineStart.x) * (lineEnd.x - lineStart.x) +\n      (point.y - lineStart.y) * (lineEnd.y - lineStart.y)) /\n    l2;\n  t = Math.max(0, Math.min(1, t));\n  const projection = {\n    x: lineStart.x + t * (lineEnd.x - lineStart.x),\n    y: lineStart.y + t * (lineEnd.y - lineStart.y),\n  };\n  return Math.sqrt(\n    Math.pow(point.x - projection.x, 2) + Math.pow(point.y - projection.y, 2)\n  );\n}\n\nfunction approximateBezierCurve(\n  start: Position,\n  cp1: Position,\n  cp2: Position,\n  end: Position,\n  segments: number\n): Position[] {\n  const points: Position[] = [];\n  for (let i = 0; i <= segments; i++) {\n    const t = i / segments;\n    const x =\n      Math.pow(1 - t, 3) * start.x +\n      3 * Math.pow(1 - t, 2) * t * cp1.x +\n      3 * (1 - t) * Math.pow(t, 2) * cp2.x +\n      Math.pow(t, 3) * end.x;\n    const y =\n      Math.pow(1 - t, 3) * start.y +\n      3 * Math.pow(1 - t, 2) * t * cp1.y +\n      3 * (1 - t) * Math.pow(t, 2) * cp2.y +\n      Math.pow(t, 3) * end.y;\n    points.push({ x, y });\n  }\n  return points;\n}\n\nfunction handleEdgeSelection(mouseX: number, mouseY: number): boolean {\n  const { scale, offset } = state;\n  let edgeClicked = false;\n  const clickPosition = {\n    x: mouseX * scale + offset.x,\n    y: mouseY * scale + offset.y,\n  };\n  data.nodes.forEach((node: Node) => (node.selected = false));\n  data.edges.forEach(edge => (edge.selected = false));\n  data.edges.forEach(edge => {\n    const startPin = data.nodes\n      .flatMap(node => getPinPositions(node, scale, offset))\n      .find(pin => pin.id === edge.start);\n    const endPin = data.nodes\n      .flatMap(node => getPinPositions(node, scale, offset))\n      .find(pin => pin.id === edge.end);\n\n    if (!startPin || !endPin) return;\n    const dx = endPin.position.x - startPin.position.x;\n    const dy = endPin.position.y - startPin.position.y;\n    const offsetMagnitude = Math.sqrt(dx * dx + dy * dy) / 3;\n    const cp1 = {\n      x: startPin.position.x + dx / 3,\n      y: startPin.position.y + (dy < 0 ? -1 : 1) * offsetMagnitude,\n    };\n    const cp2 = {\n      x: endPin.position.x - dx / 3,\n      y: endPin.position.y - (dy < 0 ? -1 : 1) * offsetMagnitude,\n    };\n\n    const points = approximateBezierCurve(\n      startPin.position,\n      cp1,\n      cp2,\n      endPin.position,\n      20\n    );\n    for (let i = 0; i < points.length - 1; i++) {\n      const distance = pointToLineDistance(\n        clickPosition,\n        points[i],\n        points[i + 1]\n      );\n\n      const selectionThreshold = 15 / scale;\n      if (distance < selectionThreshold) {\n        edgeClicked = true;\n        edge.selected = !edge.selected;\n        break;\n      }\n    }\n  });\n\n  return edgeClicked;\n}\n\nfunction handleZoom(e: WheelEvent): void {\n  const { scale, offset } = state;\n  e.preventDefault();\n  const mouseX = e.clientX - topCanvas.getBoundingClientRect().left;\n  const mouseY = e.clientY - topCanvas.getBoundingClientRect().top;\n  const wheelDelta = (-1 * e.deltaY) / 50;\n  const zoomFactor = Math.exp(wheelDelta * 0.05);\n  const newScale = Math.min(Math.max(scale * zoomFactor, 0.6), 2);\n\n  const x = (offset.x - mouseX) * (newScale / scale) + mouseX;\n  const y = (offset.y - mouseY) * (newScale / scale) + mouseY;\n  setOffset({ x, y });\n  setScale(newScale);\n  drawNow();\n}\n\nfunction handlePinSelection(\n  mouseX: number,\n  mouseY: number\n): { position: Position; id: number } | false {\n  const { scale, offset } = state;\n  let pinSelection: { position: Position; id: number } | false = false;\n  data.nodes.forEach(node => {\n    const pinPositions = getPinPositions(node, scale, offset);\n    pinPositions.forEach(pin => {\n      // Calculate the position of the mouse in the world coordinates\n      const scaledMouseX = mouseX * scale + offset.x;\n      const scaledMouseY = mouseY * scale + offset.y;\n      const dx = scaledMouseX - pin.position.x;\n      const dy = scaledMouseY - pin.position.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      const scaledSelectionThreshold = baseCircleDiameter * scale;\n\n      if (distance < scaledSelectionThreshold) {\n        const pinAlreadyConnected = data.edges.some(\n          edge => edge.start === pin.id || edge.end === pin.id\n        );\n        if (!pinAlreadyConnected) {\n          // Here, instead of just setting the position, we also include the pin's ID\n          pinSelection = {\n            position: {\n              x: (pin.position.x - offset.x) / scale,\n              y: (pin.position.y - offset.y) / scale,\n            },\n            id: pin.id, // Include the pin ID in the return value\n          };\n          data.nodes.forEach((n: Node) => (n.selected = false));\n          data.edges.forEach(edge => (edge.selected = false));\n\n          if (pin.type === 'output') {\n            data.edges\n              .filter(edge => edge.start === pin.id)\n              .forEach(edge => (edge.selected = true));\n          } else {\n            data.edges\n              .filter(edge => edge.end === pin.id)\n              .forEach(edge => (edge.selected = true));\n          }\n        }\n      }\n    });\n  });\n  return pinSelection;\n}\n\ntopCanvas.addEventListener('mousedown', function (e: MouseEvent): void {\n  const { scale, offset } = state;\n  e.preventDefault();\n  actionStartPos.x = e.clientX;\n  actionStartPos.y = e.clientY;\n  isDragging = false;\n  isPanning = false;\n\n  const mouseX = (e.clientX - topCanvas.offsetLeft - offset.x) / scale;\n  const mouseY = (e.clientY - topCanvas.offsetTop - offset.y) / scale;\n\n  let nodeClicked = false;\n  data.nodes.forEach((node: Node) => {\n    if (\n      mouseX >= node.position.x &&\n      mouseX <= node.position.x + node.size.width &&\n      mouseY >= node.position.y &&\n      mouseY <= node.position.y + node.size.height\n    ) {\n      nodeClicked = true;\n      data.edges.forEach(edge => (edge.selected = false));\n\n      if (e.shiftKey) {\n        node.selected = !node.selected;\n      } else {\n        if (!node.selected) {\n          data.nodes.forEach((n: Node) => (n.selected = false));\n          node.selected = true;\n        }\n      }\n    }\n  });\n\n  let pinClicked = handlePinSelection(mouseX, mouseY);\n\n  if (!nodeClicked && !pinClicked) {\n    let pinSelected = handlePinSelection(mouseX, mouseY);\n    if (!pinSelected) {\n      if (handleEdgeSelection(mouseX, mouseY)) {\n        drawNow();\n        return;\n      }\n    } else {\n      drawNow();\n      return;\n    }\n  }\n\n  if (e.button === 0 && !e.shiftKey && !nodeClicked && !pinClicked) {\n    // If no node or pin was clicked and the left mouse button is clicked without shift key\n    data.nodes.forEach((node: Node) => (node.selected = false));\n    data.edges.forEach(edge => (edge.selected = false));\n    setIsSelecting(true);\n    setSelectionStart({ x: mouseX, y: mouseY });\n    setSelectionEnd({ x: mouseX, y: mouseY });\n  }\n\n  if (e.button === 0 && !e.shiftKey && !nodeClicked && pinClicked) {\n    setIsJoining(true);\n    setJoinStart(pinClicked.position);\n    setJoinStartId(pinClicked.id);\n    setJoinEnd({ x: mouseX, y: mouseY });\n  }\n\n  if (e.button === 2 || (e.button === 0 && e.ctrlKey)) {\n    // If the right mouse button was clicked or the left with ctrl key, enable panning\n    panStartPos.x = e.clientX - offset.x;\n    panStartPos.y = e.clientY - offset.y;\n    isPanning = true;\n  }\n\n  drawNow();\n});\n\ntopCanvas.addEventListener('mousemove', function (e: MouseEvent): void {\n  const { scale, offset, isSelecting, isJoining } = state;\n  if (e.buttons === 1 && !isPanning) {\n    const dx = (e.clientX - actionStartPos.x) / scale;\n    const dy = (e.clientY - actionStartPos.y) / scale;\n\n    if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {\n      isDragging = true;\n      data.nodes.forEach((node: Node) => {\n        if (node.selected) {\n          node.position.x += dx;\n          node.position.y += dy;\n        }\n      });\n\n      actionStartPos.x = e.clientX;\n      actionStartPos.y = e.clientY;\n\n      drawNow();\n    }\n  }\n\n  if (e.buttons === 2 || (e.buttons === 1 && e.ctrlKey)) {\n    const x = e.clientX - panStartPos.x;\n    const y = e.clientY - panStartPos.y;\n    setOffset({ x, y });\n    drawNow();\n  }\n  if (isSelecting) {\n    const x = (e.clientX - topCanvas.offsetLeft - offset.x) / scale;\n    const y = (e.clientY - topCanvas.offsetTop - offset.y) / scale;\n    setSelectionEnd({ x, y });\n    drawNow();\n  }\n  if (isJoining) {\n    const x = (e.clientX - topCanvas.offsetLeft - offset.x) / scale;\n    const y = (e.clientY - topCanvas.offsetTop - offset.y) / scale;\n    setJoinEnd({ x, y });\n    drawNow();\n  }\n});\n\ntopCanvas.addEventListener('mouseup', function (e: MouseEvent): void {\n  const {\n    scale,\n    offset,\n    isSelecting,\n    selectionEnd,\n    selectionStart,\n    isJoining,\n    joinEnd,\n  } = state;\n\n  isDragging = false;\n  isPanning = false;\n\n  if (isSelecting) {\n    const rectStart = {\n      x: selectionStart.x * scale + offset.x,\n      y: selectionStart.y * scale + offset.y,\n    };\n    const rectEnd = {\n      x: selectionEnd.x * scale + offset.x,\n      y: selectionEnd.y * scale + offset.y,\n    };\n\n    const selectionBounds = {\n      left: Math.min(rectStart.x, rectEnd.x),\n      right: Math.max(rectStart.x, rectEnd.x),\n      top: Math.min(rectStart.y, rectEnd.y),\n      bottom: Math.max(rectStart.y, rectEnd.y),\n    };\n\n    data.nodes.forEach((node: Node) => {\n      const nodePos = {\n        x: node.position.x * scale + offset.x,\n        y: node.position.y * scale + offset.y,\n      };\n      const nodeSize = {\n        width: node.size.width * scale,\n        height: node.size.height * scale,\n      };\n\n      if (\n        nodePos.x + nodeSize.width > selectionBounds.left &&\n        nodePos.x < selectionBounds.right &&\n        nodePos.y + nodeSize.height > selectionBounds.top &&\n        nodePos.y < selectionBounds.bottom\n      ) {\n        node.selected = true;\n      }\n    });\n\n    setIsSelecting(false);\n  }\n  if (isJoining) {\n    const pinSelected = handlePinSelection(joinEnd.x, joinEnd.y) as {\n      position: Position;\n      id: number;\n    };\n\n    if (pinSelected) {\n      setJoinEndId(pinSelected.id);\n    } else {\n      setJoinStartId(null);\n      setJoinEndId(null);\n    }\n\n    if (\n      pinSelected &&\n      state.joinStartId !== null &&\n      state.joinEndId !== null &&\n      state.joinStartId !== state.joinEndId\n    ) {\n      data.edges.push({\n        start: state.joinStartId,\n        end: state.joinEndId,\n        selected: true,\n      });\n    }\n\n    setIsJoining(false);\n  }\n\n  captureState();\n  drawNow();\n});\n\ntopCanvas.addEventListener('contextmenu', function (e: MouseEvent): void {\n  e.preventDefault();\n});\n\ndocument.addEventListener('keydown', function (e: KeyboardEvent) {\n  // Check if Delete or Backspace was pressed for node/edge deletion\n  if (e.key === 'Delete' || e.key === 'Backspace') {\n    const activeElement = document.activeElement;\n    const tagName = activeElement?.tagName.toLowerCase();\n    if (tagName !== 'input' && tagName !== 'textarea') {\n      let nodesRemoved = false;\n\n      if (data.nodes.some(node => node.selected)) {\n        data.nodes = data.nodes.filter(node => !node.selected);\n        nodesRemoved = true;\n      }\n\n      if (!nodesRemoved) {\n        data.edges = data.edges.filter(edge => !edge.selected);\n      }\n\n      captureState(); // Capture the state after deletion\n      drawNow();\n    }\n  }\n\n  // Handling undo (Ctrl+Z / Cmd+Z) and redo (Ctrl+Shift+Z / Cmd+Shift+Z or Ctrl+Y / Cmd+Y)\n  if ((e.key === 'z' || e.key === 'Z') && (e.ctrlKey || e.metaKey)) {\n    e.preventDefault(); // Prevent the browser's default undo action\n    if (e.shiftKey) {\n      // Ctrl+Shift+Z or Cmd+Shift+Z for redo\n      redo();\n    } else {\n      // Ctrl+Z or Cmd+Z for undo\n      undo();\n    }\n    drawNow(); // Update the canvas with the new state\n  } else if ((e.key === 'y' || e.key === 'Y') && (e.ctrlKey || e.metaKey)) {\n    // Alternatively, Ctrl+Y or Cmd+Y for redo (common in Windows, but included for Mac for consistency)\n    e.preventDefault(); // Prevent the browser's default redo action\n    redo();\n    drawNow(); // Update the canvas with the new state\n  }\n});\n\ntopCanvas.addEventListener('wheel', handleZoom);\n\ndocument.addEventListener('dataChanged', () => {\n  drawNow();\n});\n\nfunction resizeCanvas(): void {\n  topCanvas.width = window.innerWidth;\n  topCanvas.height = window.innerHeight;\n  mainCanvas.width = window.innerWidth;\n  mainCanvas.height = window.innerHeight;\n  backgroundCanvas.width = window.innerWidth;\n  backgroundCanvas.height = window.innerHeight;\n  drawNow();\n}\n\nwindow.addEventListener('resize', resizeCanvas);\nresizeCanvas();\ndrawNow();\n"],"names":["state","scale","offset","x","y","isSelecting","selectionStart","selectionEnd","isJoining","joinStart","joinEnd","joinStartId","joinEndId","setOffset","newOffset","setIsSelecting","newIsSelecting","setSelectionEnd","newSelectionEnd","setIsJoining","newIsJoining","setJoinEnd","newJoinEnd","setJoinStartId","newJoinStartId","setJoinEndId","newJoinEndId","data","nodes","id","position","size","width","height","selected","type","name","outputPins","value","functionId","inputPins","solved","edges","start","end","history","JSON","stringify","currentIndex","captureState","currentState","length","slice","push","shift","console","log","redo","parse","baseCircleDiameter","baseSpaceBetweenCircles","getPinPositions","node","positions","circleDiameter","circleRadius","spaceBetweenCircles","_a","currentXOutput","forEach","pin","_b","currentXInput","index","drawGrid","backgroundCtx","backgroundCanvas","spacing","color","lineWidth","strokeStyle","gridSpacing","startX","startY","endX","endY","beginPath","moveTo","lineTo","stroke","draw","topCanvas","mainCanvas","topCtx","getContext","mainCtx","Error","clearRect","fillStyle","fillRect","drawBackground","borderRadius","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","quadraticCurveTo","closePath","fill","font","textX","textY","fillText","pinRadius","arc","Math","PI","smallCircleRadius","drawNodes","lineCap","edge","startNode","find","some","endNode","startPin","endPin","startPinIndex","indexOf","endPinIndex","dx","dy","offsetMagnitude","sqrt","cp1X","cp1Y","cp2X","cp2Y","bezierCurveTo","drawEdges","min","abs","save","setLineDash","rect","restore","drawSelection","ctx","drawJoiningEdge","document","getElementById","drawNow","panStartPos","isPanning","actionStartPos","pointToLineDistance","point","lineStart","lineEnd","l2","pow","t","max","projection","handleEdgeSelection","mouseX","mouseY","edgeClicked","clickPosition","flatMap","cp1","cp2","points","segments","i","approximateBezierCurve","handlePinSelection","pinSelection","scaledMouseX","scaledMouseY","n","filter","resizeCanvas","window","innerWidth","innerHeight","addEventListener","e","preventDefault","clientX","clientY","offsetLeft","offsetTop","nodeClicked","shiftKey","pinClicked","newSelectionStart","newJoinStart","button","ctrlKey","buttons","rectStart","rectEnd","selectionBounds","left","right","top","bottom","nodePos","nodeSize","pinSelected","key","activeElement","tagName","toLowerCase","nodesRemoved","metaKey","getBoundingClientRect","wheelDelta","deltaY","zoomFactor","exp","newScale","setScale"],"mappings":"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"}